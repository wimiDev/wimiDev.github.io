# 简介
这里主要想说的是，今年学习到的一种新的游戏客户端热更新的方案。这种热更新方案的相对于祖传的把所有文件都比对一遍的来说体验要好一点。

# 祖传的热更新方案
## 实现流程
这种热更新的方案比较简单，把包体内的所有文件加上md5等关键信息，并放在一个info.json文件里记录再一并把包体和这个info.json文件一起放在热更新服务器上。
info.json的格式如下：
```json
    {
        assest:[
            {file: "a.txt", md5: "1qwey87gbcv2gbdcb2eygdwef2gwd2389373xsfe3"}
        ],
        version: "1.0.0"
    }
```
游戏客户端完成初始化之后，先去热更新服务器上下载info.json,比对版本号，比对包体文件(本地文件)和info.json里面的md5是否相同，如果不相同说明这个文件有更新，则下载它。然后直到比对完这个info.json。等待下载队列完成，热更新的流程就结束了，接着跳转到游戏。

## 特点
* 实现简单，也稳定。
* 但是，需要频繁的发送网络请求，要更新的越多越容易卡。
* 文件很碎。

# 今年刚实现的一个新的热更新方案
## 实现流程
再放到热更新服务器之前，先合并包体文件。也就是把比较细碎的文件合成几个较大的文件(partN.bt)，info.json就需要记录这个文件属于哪个大文件(partN.bt)。把所有的碎文件都放到这些partN.bt之后再传到热更新服务器上。
info.json的格式如下：
```json
    {
        assest:[
            {file: "a.txt", md5: "1qwey87gbcv2gbdcb2eygdwef2gwd2389373xsfe3", bucket: "part1.bt"},
            {file: "b.txt", md5: "1zfgwe454hb456htryr6hst23eeum89qv0qw34333", bucket: "part1.bt"},
            {file: "c.txt", md5: "1qwey87gbcv2gbdcb2eygdwef2gwd2389373xsfe3", bucket: "part2.bt"},
            {file: "d.txt", md5: "1zfgwe454hb456htryr6hst23eeum89qv0qw34333", bucket: "part2.bt"}
        ],
        version: "1.0.0"
    }
```
客户端热新的时候也是先下载info.json，然后依次比对本地的包文件和info.json，把不同的找出来，然后找出这些文件都属于哪个大文件（partN.bt）比对完之后，就能得到要下载哪个大文件（partN.bt），然后请求下载，由于这些文件都经过合并，所以不用下载几千次。减少了下载请求的次数。把这些大文件下载之后还没有完成，得把需要更新的文件从大文件中还原到本地包里面。还原完之后热更新就执行完了。
## 特点
* 需要请求下载的次数少，更新较快，体验也较好。
* 流程比较复杂，打包的时候需要先合并，热更新的时候需要拆包。
* 但是，需要注意一个问题，如果要更新的文件分布在每一个大文件（partN.bt）的时候就比较麻烦，需要每个大文件都下载。就会造成卡顿和浪费，需要极力避免这种情况，比如打包的时候可以用按照修改时间对包文件进行排序，修改的文件就会在大文件里比较集中，更新的时候就能在一个大文件里。
